## 팀 구성원
- 가준영(팀장), 남의영, 왕종휘, 전병찬, 최수용
## 회고 내용 요약 (최소 500자 이상)

### 회고 주제 : `스프링 기초`
## 스프링 기초 의존성 주입

# 스프링 삼각형과 설정 정보

스프링을 이해하는데 POJP(Plain Old Java Object)를 기반으로 스프링 삼각형이라는 애칭을 가진 IoC/DI, AOP, PSA라고 하는 스프링의 3대 프로그래밍 모델에 대한 이해가 필수다.

스프링 프레임워크와 스프링 삼격형의 관계는 영어 문장과 알파벳의 관계와 같다고 할 수 있다.

그 중 IoC/DI - 제어의 역전/ 의존성 주입에 대해 알아보자!

## 1. IoC/DI - 제어의 역전/의존성 주입

### 프로그래밍에서 의존성이란?

```java
new Car();

class Car {
	new Tire();
}
```

의존성을 단순하게 정의하면 new이다. Car가 Tire에 의존한다.

의존하는 객체와 의존되는 객체 사이에 집합 관계와 구성 관계로 구분한다.

집합 관계 : 부분이 전체와 다른 생명 주기를 가질 수 있다.

구성 관계 : 부분은 전체와 같은 생명 주기를 갖는다.

### 스프링 없이 의존성 주입하기 1 - 생성자를 통한 의존성 주입

의존성 주입이란 클래스 간의 의존성을 클래스 외부에서 주입하는 것을 뜻한다. 클래스에 대한 의존성의 인터페이스화를 통한 코드 유연성 증대 + 클래스의 인스턴스를 외부에서 생성하여 주입을 하는 것을 뜻한다.

```java
Tire tire = new KoreaTire();
Car car = new Car(tire);

public class Car{
	Tire tire;

	public Car(Tire tire) {
		this.tire = tire;
	}
}
interface Tire {}
public class KoreaTire implements Tire {}
public class AmericaTire implements Tire{}
```

Car 클래스 내부에서 Tire에 의존하는것은 유연성이 떨어진다. 위에 코드는 생성자를 통해 의존성을 주입하였다.

의존성 주입을 하면 확장성도 좋아진다. 인터페이스를 구현했기에 얻는 이점이라고 볼 수 있다.

전략 패턴을 응용하고 있다.

### 스프링 없이 의존성 주입하기 2 - 속성을 통한 의존성 주입

```java
Tire tire = new KoreaTire();
Car car = new Car();
car.setTire(tire);

public class Car {
	Tire tire;
	
	public Tire getTire() {
		return tire;
	}

	public void setTire(Tire tire) {
		this.tire = tire;
	}
}
```

최근에는 속성을 통한 의존성 주입을 선호하는 사람보단 생성자를 통한 의존성 주입을 선호하는 사람들이 많다. 한번 주입된 의존성을 계속 사용하는 경우가 더 일반적이기 때문이다.

**❓스프링 프레임워크를 사용할 때 속성을 통한 의존성 주입 즉 setter getter를 많이 사용한다. 이게 좋은 코드일까?**

> setter는 일종의 가능성이다.
요즘은 불변을 선호하는 편
생성자는 단 한번의 기회를 가지는게 좋다.
생성자로 할 수 있으면 생성자로 만들자 어쩔 수 없는 경우 setter를 사용
>

### 스프링을 통한 의존성 주입 - XML 파일 사용

**⁉️현재 스프링은 XML 설정보다 Java 설정을 사용해야 한다?!**

> 더 많은 정보를 얻을 수 있다.
설정의 변경이 용이하다.
컴파일 에러를 얻을 수 있다.
>

과거에는 XML 중심으로 DI관계 설정 메타 정보를 관리하였다. 이러한 방식은 단점이 많기 때문에 지양되었고, 현재 어노테이션과 자바를 이용한 설정 방식이 떠오르기 시작했다.

이번 장은 이러한 이유로 읽고 넘어가자. 또한 XML 파일을 배우지 않았다…

요약하자면 XML 파일에 bean 태그를 이용하여 사람에게 자동차와 타이어의 의존성을 주입한다.

여기서 이점은 타이어 브랜드를 변경 할 때 XML 파일만 수정하면 재컴파일/재배포 하지 않아도 된다.

### 스프링을 통한 의존성 주입 - 스프링 설정 파일(XML)에서 속성 주입

이번 장도 위와 동일한 이유로 읽고 넘어가자.

요약하자면 사람은 자동차 판매점에 자동차를 구매 요청한다. 판매점은 자동차와 타이어를 생산하고 자동차에 타이어를 장착한다. 그리고 사람에게 자동차를 전달한다.

### 스프링을 통한 의존성 주입 - @Autowired를 통한 속성 주입

프로그래머의 3대 스킬

1. C&P: Copy & Paste / 복사 & 붙여넣기
2. D&C: Divide & Conquer / 분할 & 정복
3. C&I: Creative Idleness / 창조적 게으름

3번은 진정한 고수의 방법론이다. 스프링 프레임워크 개발팀은 어떻게 창조적 게으름을 발휘했을까

@Autowired

자동으로 속성의 설정자 메서드에 해당하는 역할을 해주겠다는 의미

```java
public class Car {
	@Autowired
	Tire tire;
}
```

### 스프링을 통한 의존성 주입 - @Resource를 통한 속성 주입

```java
public class Car {
	@Resource
	Tire tire;
}
```

Resource는 자바 표준 어노테이션 Autowired는 스프링 표준 어노테이션

### 스프링을 통한 의존성 주입 - @Autowired vs. @Resource vs. <property> 태그

|  | @Autowired | @Resource |
| --- | --- | --- |
| 출처 | 스프링 프레임워크 | 표준 자바 |
| 소속 패키지 | org.springframework.beans… | javax.annotation.Resource |
| 빈 검색 방식 | byType 먼저. 못찾으면 byName | byName 먼저. 못찾으면 byType |
| 특이사항 | @Qualifier(””) 협업 | name 어트리뷰트 |
| byName 강제하기 | @Autowired
@Qualifier(”tire1”) | @Resoucre(name=”tire1”) |

변수에 값을 할당하는 모든 곳에 의존 관계가 생긴다. 즉 대입 연산자에 의해 변수 값이 할당되는 순간에 의존이 생긴다. DI는 외부에 있는 의존 대상을 주입하는 것을 말한다. 의존 대상을 구현하고 배치할 때 SOLID와 응집도는 높이고 결합도는 낮추라는 기본 원칙에 충실해야 한다. 그래야 프로젝트의 구현과 유지보수가 수월해진다.

`@Autowired` 란

> 의존관계 주입(DI)을 할 때 사용하는 어노테이션(Annotation)이며, 의존 객체의 타입에 해당하는 빈(Bean)을 찾아 주입하는 역할을 한다.
>

Annotation 이란

> 필드, 메서드, 클래스에 컴파일 타임과 런타임에 적용될 메타데이터를 말한다.
>

`@Bean` 이란

> 스프링에서는 스프링이 제어권을 가져서 직접 생성하고 의존관계를 부여하는 오브젝트를 빈이라고 부른다.
>

<aside>
⁉️ `@Autowired` 를 지양해라!
왜?! 편리함 말고는 장점이 없다. 스프링 4.3부터는 사용하지 않는 것을 권장한다고 한다.
그럼 뭘 써야 할까?! 생성자 주입을 사용하는 것을 권장
→ `@Autowired`를 활용한 의존성 주입을 필드 주입이라고 한다.
`@RequiredArgsContsructor` 사용하자!
→ `@RequiredArgsConstructor` 를 활용한 의존성 주입은 생성자 주입이다. 스프링팀은 생성자 주입을 권장하고 있다. 즉 필드 주입을 지양하고 생성자 주입을 사용하자!

</aside>

`@RequiredArgsConstructor` 란?

> final 필드에 대해 생성자를 만들어주는 lombok의 annotation.
>

```
생성자 주입을 사용할 경우 아래와 같은 장점이 있다고 합니다.
1. 순환 참조 방지
2. 테스트 코드 작성 용이
3. 코드 악취 제거
4. 객체 변이 방지 (final 가능)
```


## 회고 과정에서 나왔던 질문 (최소 200자 이상)

### ✅ 이해 완료 리뷰
1. DI 의존성 주입에 대해 꼼꼼하게 설명해주셔서 감사합니다! 여러 종류의 의존성주입에 대해 알 수 있었습니다.!
2. 평소에 @Autowired, @RequiredArgsConstructor 둘이 뭔 차이가 있는지 궁금했었는데 앞으로는 @Autowired를 사용하지 않는 습관들 들여야겠습니다~!
3. 테스트 시에는 @Autowired를 많이 사용하는데 사용하지 않는 쪽으로 가야할것 같습니다..!
4. @Resource 는 처음 보는데 표로 비교해주셔서 바로 이해되네요 감사합니다 😄

## 회고 인증샷 & 팀 자랑
> 저희 팀은 테코톡과 같은 방식으로 회고를 진행합니다.<br>
> 매주 금요일마다 2시간씩 잡아 모든 팀원이 발표를 하고,리뷰를 하는 형태로 진행합니다.<br>

![](./img/7th_picture.png)